package com.diploma

import com.diploma.generators.TaskGenerator

/**
 * n - кол-во задач
 * d_i - время, когда задача i поступает исполнителю
 * D_i - директивный срок задачи i. Время, когда задача должна закончиться
 * t_i - время обработки задачи i
 * c_i - штраф за превышение директивного срока задачи i
 *
 * Модель:
 * x_i - переменная (начало выполнения i-той задачи)
 * y_i - (конец выполнения i-той задачи)
 *
 * Ограничения:
 * y_i = x_i + t_i (работы выполняются без прерываний)
 * x_i >= d_i (не можем начать работу раньше чем она поступила)
 * y_i <= D_i (работы не могут закончиться позже директивных сроков)
 * x_i >= y_j ИЛИ x_j >= y_i, i = 1...n (станок может выполнять только одну работу)
 *
 * Как решать:
 * 1) Полный перебор n! перестановок O(n!)
 * Критерий нарушения D зависит от Y
 * Минимизируем критерий => находим самую лучшую перестановку
 * Можем не получить решение удовлетворяющее всем ограничениям (называется допустимым) - Тогда уберём 3 ограничение
 * D - вообще говоря должно генерироваться по нормальному распределению
 * 2) Эвристики (например восхождение на холм) O(n^2)
 * Для исходных данных генерируется "Коэффициент" (например (d+D)/t )
 * Сортируем по убыванию => получаем перестановку
 *
 * Считаем относительное отклонение Д(ельта), например = (F^эвр - F^0)/F^0
 *
 * Задачи хранить нигде не надо
 */
fun main() {
	val g = TaskGenerator()
	val x = g.generateTasks(10, 1..5, 1..5, 1..5)
	for (i in x)
		println(i)
}
